- 多进程并发 多线程并发<br>

- 共享数据会带来问题，以双向链表举例

- 使用互斥量保护共享数据，可能带来死锁  一种解决办法就是让两个互斥量总以相同的顺序上锁：总在互斥量B之前锁住互斥量A，就永远不会死锁，另一种方式是
lock()同时锁住两个变量，然后将锁住的转给lock_guard(std::adopt_lock是参数)

- unique_lock 允许何时、及如何锁定互斥量

- 保护共享变量的替代措施  用std::call_once来处理这种情况


