- 双击时从磁盘加载到内存，

- printf("%p",&a)  看存储   打两个断点，修改内存值

- 变量表   内存地址和声明的变量名

- a+1属于寄存器，只能给变量赋值，变量在内存,变量通过寄存器赋值

- -asm(插入汇编)

- {

  mov eax,10

  mov a,eax

  }

- c语言，老版本的编译器，gcc （未勾选支持c11）vc2010之前，调用函数后定义变量，会出问题，

- 关键字  标识符

- c语言中 const int型不可直接修改， 可通过内存修改，*（int*）(&a)=00001        //注意句子中有星号  int* 是将const int *实现转换               const只能避免你直接对常量赋值

- c语言只能操作内存 汇编还可以操作寄存器， #define是真正意义上的定义常量，c语言无法通过取地址对该常量进行更改，因为define 定义的宏就是直接取寄存器里的数，c语言无法取寄存器里的地址

- a=a+b  交换变量

- b=a-b

- a=a-b

- 低字节数据往高字节数据转换，带符号的按照符号填充  原码通过反码加一计算补码，补码存在计算机中，补码的存在是为了计算机能分辨出几乎所有的数

- 数据溢出高位截断

- getchar

- unsigned int num=-1     int num=-1  前一个num会很大，后一个num就是一个小于0的数

- shellexecutea 编写程序执行某个软件

- 库函数文件，在c语言里可以不加，能编译，为了代码规范，应该加

- 为支持跨平台操作，不能引入第三方库（如windows.h）,一般只引标准库

- 代码稳定性好，就是把错误都处理了

- c和c++里面函数体不能再包含函数体，c++可以包含lamda

- 当某个位置进行函数调用时，表层上通过函数名进行调用，实际上，有一个函数表，函数名的地址是对应的函数所在函数表的位置，函数表的该地址上，有执行该函数的地址

- c语言类型返回不一致，给个警告，c++会有严格的类型限制

- c语言对未定义声明的函数类型调用时可以编译，但是不能链接，即就是，可以编译并不一定能运行

- 实际上c函数声明加不加都可以，为了函数工程，需要加

- 默认不写，c返回int

- 函数栈展开，由main 最后开始推入栈中

- vs2013会进行指针安全检查（初始化），其他编译器就不知道了

- 野指针（分配随机内存，可能指向操作系统，不可访问），空指针（指向00000），不可访问

- 32位 cpu寻址能力     指针与编译器/操作系统有关  eax  32位  rax    64位

- 64位计算机，可以做32和64位计算

- int num=1  cpu从代码区读取数据转换为二进制，再赋值给num,内存之间不能直接赋值

- while(1)

- {

- malloc(1024*1024*100)

- }

- 32  进行最大2G 64进程最大1024g

- 栈的大小是编译器维护   vs中链接器 系统 堆栈保留大小可对其调整，默认1mb

- vs 可打开多个内存查看器

- 32 堆最大2G

- 多线程每一个都有自己的栈

- 内存堆栈和数据结构堆栈

- 什么是关闭编译器的安全检查功能

- char  s1='a'  一个字节

-  wchar_t=L'0' 两个字节  宽字符

- “L我” 不是一个“我”等于两个字符，也不是等于一个字符，是一个“我”占两个字节

- L“L我” 每个字符占两个字节   “我是一个字符”  或者不用L，改unicode为多字符集

- 任何类型地址格式都一样，故任何类型的指针都可赋给void *(只有首地址)，有类型的，地址步长解析方式

- sizeof 是关键字

- 函数的返回值放在 寄存器的catche或者编译器的备份内存，不可取地址

- &取地址其实也隐式得到类型，所有在对有const的取地址重新赋值时，要显示转类型

- scanf也需要绝对的匹配才能输入，你以为你输入的是整数，其实是字符，并且scanf是对地址赋值

- 安全锁 

- 线程传入参数  1线程安全 2堆栈大小 3线程的入口点 4函数的参数  5 立刻执行 6保存线程的id 

- malloc(不会初始类型  一个参数   整体大小如25个int   返回指针)   calloc（会初始类型    两个参数， 个数 类型  

  返回指针 ）   realloc （p=realloc(p,20)）   _realloc 

- 指针最大用途 间接修改数据  间接调用代码  

- exe  dll

- 一个进程无法修改另一个进程数据，但是模块可以，用dll

- 外部函数可以被其他源文件所调用，extern可以滤去

- 作用域  理论上可以调用的地方  可见域  实际可以调用的地方   外部函数 无需声明直接调用，  内部函数声明位置与调用，可调试区别

- 结构体变量 作为全局变量 有声明与定义的差别  只定义一次 可以声明多次  局部声明与定义没差

  不同的源文件引用外部结构体变量，不仅需要外部声明(extern)还需要结构体定义 ，  

- static函数又叫内部函数

- const int n=10   int a[n];  可行 寄存器中不可变化 ，    int n=10   int a[n];  不可行 内存中，易变化

- c++虽然也可以像c一样对const 变量从内存上修改，但是，c++会进行优化，也就是虽然你之前已经对该变量在内存中的值做了修改，但是，编译器因为知道该变量是常量，并且已经知道了该值，并不会从内存中读，而是直接从寄存器产生该值，忽略了内存中的值    但是const数组不会优化

- constexp 表示函数返回值或者其他表达式返回的是常量

-  int * p= new int(4)    const int * &rp  ()(const int *&) p )

-  malloc 返回的指针  freeh后free还要让其指向nullptr,否则改指针仍然指向内存，访问时会得到垃圾数据

- 结构体对齐  结构体大小必须可以整除最宽基本成员（int float...unsign算吗）结构体成员的地址-结构体首地址=偏移量，必须是当前成员大小的整数倍

- 高内聚 低耦合

- 头文件一般放声明，如果加了对全局变量的定义，而该头文件又被多个源文件所包含，则在编译时，头文件的定义被多次拷贝进源文件，出现全局变量的重复定义

- [](){}();

- struct Node{

  Node  *p      //不能是Node p 这样会一直循环找类型，是错误的语法

  }  结构体嵌套就是赋值   

  

  - 防止内存泄露的方法   对malloc、free进行包装,全局变量++ --  print全局变量便可知道是否有内存泄漏

  - struct  Mem{

    void *p ; //分配的内存地址

    int length    //分配的内存长度

    }

    struct  Memory
    {

    struct Mem  *p;  //指向管理内存地址数组的首地址

    int i;//分配i++,free i--

  

  struct  Mem{

  void *p ; //分配的内存地址

  int length    //分配的内存长度

  }

  struct  linknode {

  struct Mem  *p;  //保存指针，

  struct linknode *pnext  指向下一个节点

  }node ,*PNODE;

  

  

  无法解析的外部命令 编译声明过了 但是链接的时候没有找到函数

  有些情况，对函数只有声明没有定义，可以过编译，但是不能过链接，因为链接的时候要载入函数实体

  可以通过vstool来查看obj文件,具体步骤为用vstool切换到mingwvars.bat所在目录并打开mingwvars.bat，在其中cd到.obj目录，然后用一个命令打开.obj

  可以用#define引用文件标识符 ， 但要注意是 ## 左右都有， 一个# 是将其变成字符

  “”可以替换<>，<>是直接从系统目录找

  用 #define isdebbug 和 条件编译方便进行调试

  #pragma warning(disable) 禁止某个报错，#pragma的许多设置等同于项目的属性设置

  有时候为便于调试可以内置宏 如_LINE_ __FILE__  _FUNCTION_

  

  

  

  #define 一行定义不完要切换时用 \

  头文件不会翻译成obj,只有点.c会翻译成obj, .h不可以直接编译 要附加到.c内部

  即时窗口可以在调试时临时修改某变量值。但是不能在其中调用函数 自动窗口也有类似功能

  调用模块可以查看dll

  写一个线程在gpu里面执行  gpu线程

  右上角代码图

  #define (2+8) 加括号防止替换错误

  #undef MN 取消define的作用域

  #define 对函数替换可以将函数变成内联函数，减少对函数的调用时间， 带#号 科实现 hell替换为 “hell”

  #include  头文件时也可以指明相对路径 绝对路径

  为了代码优化可以选择编译，即选择性对代码编译

  如果头文件中有对全局变量的定义，被另一个文件所包含，就会出现重复定义，为解决此问题，可用

  #if ndef N  #define n 这样头文件第一次被包含的时候 n未被定义可以定义，后面执行就只能定义一次

  但是这种方式不能解决跨文件重复定义的问题

  #error 功能

  #programa code_seg() 解决编译的独立性

  #progma onece 解决单个文件重复包含的问，不能被两个文件包含

  #pragma comment //链接库文件  不写可以编译，但不能链接

  assert 提示一个错误 便于调试

  #pragma  pack(1)   指定结构体按照 1248 16对齐 

  #pragma intrinsic(fun1,fun2)  设置fun1,2 为内联函数

  预编译头的作用  本身某个头可能就包含大量需要预先编译的，如果不预编译，会等待较长时间，而使用预编译头，等于该头中包含已编译好的obj文件，不需要再编译了

  MSDN

  

  

  

  

  

  

  

  

  

  

  

  

  网页各种端的支持

  key map 快捷键

  

  
