- 可以向一个算法传递任何类别的可调用对象（calable object).对于一个对象或
一个表达式,如果可以对其使用调用运算符（参见1.5.2 节,第21页）,则称它为可调用
的
- 函数 函数指针 重载了函数调用运算符的类 lamda表达式

-可以忽略参数列表和返问类型,但必须永远包含捕获列表和函数  []{}    [](){}()

- 普通函数不同,lambda不能有默认参数（参见6.5.1节,第211页)。因此,一个 lambd调用的实参数且永远与形参数且相等

-  如果lambda可能在函数结束后执行,捕获的引用指向的局部变量己经消失。

- 我们不能拷贝 ostream对象（参见8.1.1 节,第279页),因此捕获 os的唯一方法就是
捕获其引用（或指向 os的指针）
- 我们捕获一个指针或选代器,或采用引用捕获方式,就必须确保在lambda执
|行时,绑定到迭代器、指针或引用的对象仍然存在。而且,雷要保证对象具有预期的值。
在lambda从创建到它执行的这段时间内,可能有代码改变绑定的对象的值
- 一般来说。我们应该尽量减少捕获的数据量。来避免潜在的捕获造成的问题
-  隐式捕获 为了指示编译器推断捕获列表,应在捕获列表中
写一个s或=。s
- 如果我们希望对一部分变量采用值捕获,对其他变量采用引用捕获,可以混合使用隐
式捕获和显式捕获
- 我们混合使用隐式捕获和显式捕获时,捕获列表中的第一个元素必须是一个&或=
- 默认情况下，lamda都只包含单一的 return 语句。因此,我们还未遇到必须指定返回类型的情况。默认情况下，如果一个lambda包含return之外的语句，编译器假定lamda返回void
- 需要为一个lambda定义返回类型时,必须使用尾置返回米型

- 对于捕获局部变量的lambda,用函数来替换它就不是那么容易了，我们可以试着写一个包含两个参数的函数来等效替换lamda,但是，我们不能用这个函数作为find_ if的一个参数,find_ if接受一个一元谓词，因此传递给find_ if的可调用对象必须接受单一参数。我们可以使用标准库bind函数来解决这个问题，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。






