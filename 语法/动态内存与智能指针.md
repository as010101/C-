

- 默认初始化的智能指针(shared_ptr)中保存着一个空指针(sizeof(*p)可以取到内存)

- 最安全的分配和使用动态内存的方法是调用一个名为make_ shared 的标准库的数,此函数在动态内存中分配-一个对象并初始化它，返回指向此对象的shared ptr,make_ shared也
定义在头文件memory中。


- 当进行拷贝或赋值操作时，每个shared_ ptr 都会记录有多少个其他shared_ ptr指向相同的对象

- 当指向一个对象的最后一一个shared ptr被销毁时，shared ptr类会自动销毁此对象

- 如果你将shared ptr存放于一个容器中，而后不再需要全部元素，而只使
用其中一部分，要记得用erase删除不再需要的那些元素

- 程序使用动态内存出于以下三种原因之一-:
1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的准确类型
3.程序需要在多个对象间共享数据

- 使用动态内存的一个常见原因是允许多个对象共享相同的状态。(即多个对象指向堆内存，局部内存难以共享)


- 忘记释放动态内存会导致人们常说的“内存泄漏”问题，(忘记delete delete 两次  使用已经释放的对象)

- 动态内存的一-个基本问题是可能有多个指针指向相同的内存。在delete内存之后重
置指针的方法只对这个指针有效，对其他任何仍指向(已释放的)内存的指针是没有作用
的。例如:
```
int *p(new int(42)); // p指向动态内存
auto q=P;
// p和q指向相同的内存
delete p;
// p和q均变为无效
P = nullptr;
//指出p不再绑定到任何对象
```
并未对q赋值为q=nullptr 

- 智能指针类型定义了一个名为get的函数(参见表12.1), 它返回一个内置指针，
指向智能指针管理的对象。此函数是为了这样-种情况而设计的:我们需要向不能使用智
能指针的代码传递一“个内置指针。使用get返回的指针的代码不能delete此指针。

- get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针
的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针
或者为另一个智能指针赋值。


 - shared_ ptr还定义了其他一些操作， 参见表12.2和表12.3所示。我们可以用reset
来将一个新的指针赋予一-个shared_ ptr:
```
p = new int (1024);
//错误:不能将一个指针赋予shared_ ptr
p.reset (new int (1024)); // 正确: p指向一个新对象
```
- 与赋值类似，reset 会更新引用计数，如果需要的话，会释放p指向的对象。reset成
员经常与unique -起使用，来控制多个shared_ ptr 共享的对象。在改变底层对象之
前，我们检查自已是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的
拷贝:
```
if (!p.unique())
p. reset (new string(*p)); //我们不是唯一用户;分配新的拷贝
*p += newVal; //现在我们知道自己是唯一的用户，可以改变对象的值
```

- 智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的
前提下。为了正确使用智能指针，我们必须坚持一些基本规范:

●不使用相同的内置指针值初始化(或reset)多个智能指针。
●不delete get()返回的指针。
●不使用get()初始化或reset另一个智能指针。
●如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的
指针就变为无效了。
●如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器

- 与shared_ ptr不同，没有类似make_ shared 的标准库函数返回一个unique_ ptr。当我们定义一一个 unique_ ptr 时，需要将其绑定到-一个new返回的指针
上。类似shared_ ptr, 初始化unique_ _ptr 必须采用直接初始化形式:
unique_ ptr 不支持赋值和拷贝


- 虽然我们不能拷贝或赋值unique_ ptr,但可以通过调用release或reset将指针的
所有权从一个(非const) unique_ ptr 转移给另一个unique:
```
//将所有权从p1 (指向string Stegosaurus,本身也是一个unique_ptr) 转移给p2    
unique_ ptr<string> p2 (pl.release()); // release 将p1置为空
unique_ ptr<string> p3 (new string("Trex")) ;
//将所有权从p3转移给p2
p2. reset (p3.release()); // reset 释放了p2原来指向的内存
```

- 不能拷贝unique_ _ptr 的规则有一一个例外: 我们可以拷贝或赋值-一个将 要被销毁的
unique_ ptr。最常见的例子是从函数返回-一个unique_ ptr:
```
unique_ ptr<int> clone(int p) {
//正确:从int*创建一个unique_ ptr<int>
return unique_ ptr<int> (new int(p) ) ;
}
```

- weak_ptr
weak_ ptr (见表12.5)是一种不控制所指向对象生存期的智能指针，它指向由一个
shared_ ptr管理的对象。
weak访问引用指向的对象，通过lock()接口返回shared_ptr,再用shared_ptr去访问对象

引用计数的出现，解决了对象独占的问题，但是也带来了循环引用的困扰，使用`weak_ptr`可以打破这种循环，智能指针shared_ptr的出现，就是为了共享，实现多个指针共享同一个对象

weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。
weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数。
weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。
由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。












