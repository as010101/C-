

默认初始化的智能指针(shared_ptr)中保存着一个空指针(sizeof(*p)可以取到内存)

最安全的分配和使用动态内存的方法是调用一个名为make_ shared 的标准库的数,此函数在动态内存中分配-一个对象并初始化它，返回指向此对象的shared ptr,make_ shared也
定义在头文件memory中。


当进行拷贝或赋值操作时，每个shared_ ptr 都会记录有多少个其他shared_ ptr指向相同的对象

当指向一个对象的最后一一个snared ptr被销毁时，shared ptr类会自动销毁此对象

如果你将shared ptr存放于一个容器中，而后不再需要全部元素，而只使
用其中一部分，要记得用erase删除不再需要的那些元素

程序使用动态内存出于以下三种原因之一-:
1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的准确类型
3.程序需要在多个对象间共享数据

使用动态内存的一个常见原因是允许多个对象共享相同的状态。(即多个对象指向堆内存，局部内存难以共享)


忘记释放动态内存会导致人们常说的“内存泄漏”问题，(忘记delete delete 两次  使用已经释放的对象)

动态内存的一-个基本问题是可能有多个指针指向相同的内存。在delete内存之后重
置指针的方法只对这个指针有效，对其他任何仍指向(已释放的)内存的指针是没有作用
的。例如:
int *p(new int(42)); // p指向动态内存
auto q=P;
// p和q指向相同的内存
delete p;
// p和q均变为无效
P = nullptr;
//指出p不再绑定到任何对象

并未对q赋值为q=nullptr 








