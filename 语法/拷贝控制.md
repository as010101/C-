
- 如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值一
则此构造函数是拷贝构造函数

- 构造函数的第一个参数必须是一个引用类型,原因我们稍后解释。虽然我们可以定义
一个接受非 const 引用的拷贝构造函数,但此参数几乎总是一个const的引用。拷贝构
造函数在几种情况下都会被隐式地使用,因此,拷贝构造函数通常不应该是 explicit
的
- 成员的类型决定了它如何拷贝,对类类型的成员,会使用其拷贝构造函数来拷贝:
内置类型的成员则直接拷贝。

- 使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy
initialization）时,我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换

- 使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配（参见6.4节,第209
页）米选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy
initialization）时,我们要求编译器将右侧运算对象拷贝到正在创建的对象中如果需要的
话还要进行类型转换

- 拷贝初始化不仅在我们用=定义变量时会发生,在下列情况下也会发生
1 将一个对象作为实参传递给一个非引用类型的形参
2 从一个返回类型为非引用类型的函数返回一个对象
3 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
4 某些类类型还会对它们所分配的对象使用拷贝初始化

- 编译器略过了拷贝/移动构造函数,但在这个程序点上,找贝/移动构造函数必
|须是存在目可访问的（例如,不能是private的

- 一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this 参
数。对于一个二元运算符,例如赋值运算符.其右侧运算对象作为显式参数传递 

- 如何理解（为了与内置类型的赋值（参见4.4节,第129页)保持一致,赋值运算符通常返回一个指
向其左侧运算对象的引用。另外值得注意的是,标准库通常要求保存在容器中的类型要具
有赋值运算符,且其返回值是左侧运算对象的引）
1 由于内置类型的赋值运算符的左侧对象必须是一个可修改的左值
2 赋值运算的结果是它的左侧运算对象，并且是一个左值

- 通过将拷贝控制成员定义为=default 米显式地要求编译器生成合成的版本(也就是显式地让编译器生成默认的对应的构造函数、)
Sales_data (const Sales_data6)= default;
Sales_datas operator=(const Sales_data ）;
~Sales_data(）=default;
当我们在类内用=default 修饰成员的声明时,合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数,应该
只对成员的类外定义使用=default

- 可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了它们,但不能以任何
方式使用它们。 =delete

- delete与default的另一个不同之处是,我们可以对任何函数指定=delete(我们只能对
编译器可以合成的默认构造函数或拷贝控制成员使用=default）

- 析构函数理论上不应该与delete使用 

- 如果一个类有数据成员不能默认构造、拷贝、复制或析构,则对应的成员函数将被定义为删除的。
 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的
 
 -  如果一个类有const 成员,则它不能使用合成的拷贝赋值运算符。毕竟,此运算符试图赋值所有成员,而将一个新值赋予一
个 const 对象是不可能的。

