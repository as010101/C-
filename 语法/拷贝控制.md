
- 如果一个构造函数的第一个参数是自身类类型的引用,且任何额外参数都有默认值一
则此构造函数是拷贝构造函数

- 构造函数的第一个参数必须是一个引用类型,原因我们稍后解释。虽然我们可以定义
一个接受非 const 引用的拷贝构造函数,但此参数几乎总是一个const的引用。拷贝构
造函数在几种情况下都会被隐式地使用,因此,拷贝构造函数通常不应该是 explicit
的
- 成员的类型决定了它如何拷贝,对类类型的成员,会使用其拷贝构造函数来拷贝:
内置类型的成员则直接拷贝。

- 使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy
initialization）时,我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换

- 使用直接初始化时,我们实际上是要求编译器使用普通的函数匹配（参见6.4节,第209
页）米选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy
initialization）时,我们要求编译器将右侧运算对象拷贝到正在创建的对象中如果需要的
话还要进行类型转换

- 拷贝初始化不仅在我们用=定义变量时会发生,在下列情况下也会发生
1 将一个对象作为实参传递给一个非引用类型的形参
2 从一个返回类型为非引用类型的函数返回一个对象
3 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
4 某些类类型还会对它们所分配的对象使用拷贝初始化

- 编译器略过了拷贝/移动构造函数,但在这个程序点上,找贝/移动构造函数必
|须是存在目可访问的（例如,不能是private的

- 一个运算符是一个成员函数,其左侧运算对象就绑定到隐式的this 参
数。对于一个二元运算符,例如赋值运算符.其右侧运算对象作为显式参数传递 

- 如何理解（为了与内置类型的赋值（参见4.4节,第129页)保持一致,赋值运算符通常返回一个指
向其左侧运算对象的引用。另外值得注意的是,标准库通常要求保存在容器中的类型要具
有赋值运算符,且其返回值是左侧运算对象的引）
1 由于内置类型的赋值运算符的左侧对象必须是一个可修改的左值
2 赋值运算的结果是它的左侧运算对象，并且是一个左值

- 通过将拷贝控制成员定义为=default 米显式地要求编译器生成合成的版本(也就是显式地让编译器生成默认的对应的构造函数、)
Sales_data (const Sales_data6)= default;
Sales_datas operator=(const Sales_data ）;




~Sales_data(）=default;
当我们在类内用=default 修饰成员的声明时,合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数,应该
只对成员的类外定义使用=default

- 可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了它们,但不能以任何
方式使用它们。 =delete

- delete与default的另一个不同之处是,我们可以对任何函数指定=delete(我们只能对
编译器可以合成的默认构造函数或拷贝控制成员使用=default）

- 析构函数理论上不应该与delete使用 

- 如果一个类有数据成员不能默认构造、拷贝、复制或析构,则对应的成员函数将被定义为删除的。
 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的
 
 -  如果一个类有const 成员,则它不能使用合成的拷贝赋值运算符。毕竟,此运算符试图赋值所有成员,而将一个新值赋予一
个 const 对象是不可能的。


- 类
1 类的行为像一个值。当我们拷贝一个像值的对象时,副本和原对象是完全独立的
2 类的行为像一个指针，行为像指针的类则共享状态。当我们拷贝一个这种类的对象时,副本和原对象使用相
同的底层数据。改变副本也会改变原对象
3 既不像值也不像指针 IO类型和 unique ptr不允许拷贝或赋值

- 在重写赋值运算符的时候，要防范自赋值  在delete当前对象（不是参数传入的对象）的指针时，要考虑先将该指针指向的值赋给临时变量，在对后置++函数也有类似的操作

- 使用引用计数管理行为像指针的类的堆内存  类的拷贝成员可以篡改引用计数
-  对于类行为像指针的赋值运算符函数，为防范自赋值，由于自赋值也会增加指针的引用计数（如果不管理好的话），因此，要判断。。。
#  对象移动
1 避免不必要的拷贝操作
2 有些类包含不能被共享的资源
- 在新标准中,我们可以用容器保存不可拷贝的类型,只要它们能被移动即可 
-  为了支持移动操作，新标准引入了一种新的引用类型，右值引用
- 不能将一个右值引用直接绑定到一个左值上,但我们可以显式地将一个左值转换
为对应的右值引用类型 标准库的move函数

-移动构造函数的第一个实参是const&&类型，与拷贝函数一样，任何额外的参数都必须有默认值
- 一旦资源完成移动,源对象必须不再指向被移动的资源
- 同样地，移动赋值运算符必须也要处理自赋值（直接检查两个对象是否相同，如果相同直接返回this指针，否则，释放当前对象的内存
，并接管右侧对象的数据，之后将右侧对象的相应指针指向nullptr）
- 我们编写一个移动操作时,必须确保移后源对象进入一个可析构的状态

-默认的合成
1. 与处理拷贝构造函数和拷贝赋值运算符一样,编译器也会合成移动构造函数和移动赋
值运算符。
2 但是,合成移动操作的条件与合成拷贝操作的条件大不相同。
如果我们不声明自己的拷贝构造函数或拷贝赋值运算符,编译器总会为我
们合成这些操作。拷贝操作要么被定义为逐成员拷贝,要么被定义为对象赋值,要么被定义为删除的函数。
3 与拷贝操作不同,编译器根本不会为某些类合成移动操作。特别是,如果一个类定义题
了自己的拷贝构造函数、拷贝赋值运算符或者析构函数,编译器就不会为它合成移动构造
函数和移动赋值运算符了。因此,某些类就没有移动构造函数或移动赋值运算符。 4 如果一个类没有移动操作,通过正常的函数匹配,类会使用对应的拷
贝操作来代替移动操作。 5 只有当一个类没有定义任何自己版本的拷贝控制成员,且类的每个非static 数据成
员都可以移动时,编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动
内置类型的成员。如果一个成员是类类型,且该类有对应的移动操作,编译器也能移动这
个成员

-  值得注意的是,用拷贝构造函数代替移动构造函数几乎肯定是安全的(赋值运算符的情况类似）。一般情况下,拷贝构造函数满足对应的移动构造函数的要求:它会拷贝给定对象,并将原对象置于有效状态,实际上,拷贝构造函数甚至都不会改变原对象的值。

-   区分移动和拷贝的重裁函数    const T&, T &&

 

  
