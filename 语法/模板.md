当我们希望通知编译器一个名字表示类型时，必须使用关键字typename,而
不能使用class。

就像我们能为函数参数提供默认实参- -样(参见6.5.1 节，第211页),我们也可以提
供默认模板实参( default template argument)。

- 控制实例化

可以在某个文件中对模板定义，其他文件中对该泛型用extern声明
由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使
用此实例化版本的代码之前





首先遇到类模板的使用，如果是分离式编译，那么main.cpp肯定找不到类模板的实现，把找到的任务甩给链接器，链接器则根据每一个cpp文件生成的.obj中的符号表来确定类模板的实现，但是类模板的一个特点就是没有用到的时候不会去实现它，它并没有并转换成二进制代码，所以链接器找不到它的实现，就报错了。
我觉得应该是当看见声明而没有定义，那么编译器会认为在别的地方有具体实现，如果在别的地方找不到就会报错，



flip1(F f,T1 t1,T2 t2)
{
 f(t2,t1);
}


flip2(F f,T1 && t1,T2 && t2)
{
 f(t2,t1);
}

f(int v1,int  &v2)

flip1(f,j,42)

flip2(f,j,42)

template <typename F, typename T1，typename T2>
void flip(F f，T1 &&t1， T2 &&t2)
{
f (std: : forward<T2> (t2)，std: : forward<Tl> (t1) ) ;
}

函数参数同其他变量一样，都是左值表达式
std: : forward<T2>可以保持T2的类型
