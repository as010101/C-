当我们希望通知编译器一个名字表示类型时，必须使用关键字typename,而
不能使用class。

就像我们能为函数参数提供默认实参- -样(参见6.5.1 节，第211页),我们也可以提
供默认模板实参( default template argument)。

- 控制实例化

可以在某个文件中对模板定义，其他文件中对该泛型用extern声明
由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使
用此实例化版本的代码之前

由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使
用此实例化版本的代码之前

由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使
用此实例化版本的代码之前

对C++编译器而言，当调用函数的时候，编译器只需要看到函数的声明。当定义类类型的对象时，编译器只需要知道类的定义，而不需要知道类的实现代码。因此，因该将类的定义和函数声明放在头文件中，而普通函数和类成员函数的定义放在源文件中。
       但在处理模板函数和类模板时，问题发生了变化。要进行实例化模板函数和类模板，要求编译器在实例化模板时必须在上下文中可以查看到其定义实体；而反过来，在看到实例化模板之前，编译器对模板的定义体是不处理的——原因很简单，编译器怎么会预先知道 typename 实参是什么呢？因此模板的实例化与定义体必须放到同一翻译单元中。


