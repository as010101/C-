

int  * const * p  
int  ** const p   ---p隔const最近   故p这个二重指针地址是const

int const *const *p 
int * const *const p  
不能 int const const 这种属于修饰重复



const修饰的翻译期标识符具有常量语义，对于编译期（源代码）而言，必须在定义时同时被初始化，且一旦被定义即无法修改，否则产生编译错误。
对于编译器而言，如果用于初始化const对象的值在编译期即能被确定，则可以把这个const对象优化掉，即通过类型检查后用这个值代替这个对象本身（这点效果和宏定义替换类似，但更安全），这被称为编译期const对象。编译期const对象在编译期完全确定，对于运行期而言相当于不存在。由于内嵌至数据段中，只是直接复制到内存，无所谓“初始化”（但是这点行为上和基本类型数据的初始化类似）。
对于无法在编译期确定的运行期常量，一旦通过编译链接，在运行期的初始化行为，和对象本身被创建的时机相同——例如全局/静态对象在进程初始化时被初始化，作为函数参数的const对象（包括任何引用类型）在参数传递生成参数时同时初始化
